<section class="chapter-section">
    <h2>Type guards (typeof, instanceof, user-defined guards)</h2>
    <p>Type guards jsou výrazy, které provádějí kontrolu typů za běhu, umožňují TypeScriptu odvodit typy v určitých blocích kódu.</p>
    <pre><code>// Základní type guards pomocí typeof
function zpracujHodnotu(hodnota: string | number): string {
    if (typeof hodnota === "string") {
        // TypeScript ví, že hodnota je string
        return hodnota.toUpperCase();
    } else {
        // TypeScript ví, že hodnota je number
        return hodnota.toFixed(2);
    }
}

// Type guard pomocí instanceof pro práci s třídami
class Zamestnanec {
    jmeno: string;
    plat: number;
    
    constructor(jmeno: string, plat: number) {
        this.jmeno = jmeno;
        this.plat = plat;
    }
    
    dejOdmenu(): number {
        return this.plat * 0.1;
    }
}

class Kontraktor {
    jmeno: string;
    hodinovaSazba: number;
    
    constructor(jmeno: string, hodinovaSazba: number) {
        this.jmeno = jmeno;
        this.hodinovaSazba = hodinovaSazba;
    }
    
    vypoctiMzdu(hodiny: number): number {
        return this.hodinovaSazba * hodiny;
    }
}

function zpracujPracovnika(osoba: Zamestnanec | Kontraktor): string {
    let vysledek = `Jméno: ${osoba.jmeno}, `;
    
    if (osoba instanceof Zamestnanec) {
        // TypeScript ví, že osoba je instance Zamestnanec
        vysledek += `Odměna: ${osoba.dejOdmenu()} Kč`;
    } else {
        // TypeScript ví, že osoba je instance Kontraktor
        vysledek += `Hodinová sazba: ${osoba.hodinovaSazba} Kč`;
    }
    
    return vysledek;
}</code></pre>
</section>

<section class="chapter-section">
    <h2>Vlastní typové hlídky (user-defined type guards)</h2>
    <p>Můžete vytvořit vlastní funkce pro typové hlídky pomocí typových predikátů.</p>
    <pre><code>// Vlastní typové hlídky používající typové predikáty
interface Auto {
    typ: "auto";
    registracniZnacka: string;
    pocetSedadel: number;
}

interface Letadlo {
    typ: "letadlo";
    oznaceni: string;
    rozpeti: number;
}

type Vozidlo = Auto | Letadlo;

// Funkce s typovým predikátem
function jeAuto(vozidlo: Vozidlo): vozidlo is Auto {
    return vozidlo.typ === "auto";
}

function jeLetadlo(vozidlo: Vozidlo): vozidlo is Letadlo {
    return vozidlo.typ === "letadlo";
}

// Použití vlastní typové hlídky
function zobrazInfoOVozidle(vozidlo: Vozidlo): string {
    if (jeAuto(vozidlo)) {
        // TypeScript ví, že vozidlo je Auto
        return `Auto s SPZ: ${vozidlo.registracniZnacka}, místa: ${vozidlo.pocetSedadel}`;
    } else {
        // TypeScript ví, že vozidlo je Letadlo
        return `Letadlo: ${vozidlo.oznaceni}, rozpětí: ${vozidlo.rozpeti} m`;
    }
}

const mojeAuto: Auto = {
    typ: "auto",
    registracniZnacka: "1AB 2345",
    pocetSedadel: 5
};

const letadlo: Letadlo = {
    typ: "letadlo",
    oznaceni: "Boeing 737",
    rozpeti: 35.8
};

console.log(zobrazInfoOVozidle(mojeAuto));
console.log(zobrazInfoOVozidle(letadlo));</code></pre>
</section>

<section class="chapter-section">
    <h2>Typové predikáty a diskriminační unie</h2>
    <p>Diskriminační unie jsou výkonný způsob, jak pracovat s různými typy, které mají společnou vlastnost identifikující jejich typ.</p>
    <pre><code>// Diskriminační unie s vlastností "druh"
interface Kruh {
    druh: "kruh";
    polomer: number;
}

interface Ctverec {
    druh: "ctverec";
    strana: number;
}

interface Obdelnik {
    druh: "obdelnik";
    sirka: number;
    vyska: number;
}

type Tvar = Kruh | Ctverec | Obdelnik;

// Exhaustive checking (úplná kontrola všech možností)
function vypoctiPlochu(tvar: Tvar): number {
    switch (tvar.druh) {
        case "kruh":
            return Math.PI * tvar.polomer ** 2;
        case "ctverec":
            return tvar.strana ** 2;
        case "obdelnik":
            return tvar.sirka * tvar.vyska;
        default:
            // Exhaustive check - detekuje, pokud přidáme nový typ a nezpracujeme ho
            const _vyctoveKontrolaTypu: never = tvar;
            throw new Error(`Nepodporovaný tvar: ${_vyctoveKontrolaTypu}`);
    }
}

const kruh: Kruh = {
    druh: "kruh",
    polomer: 5
};

const ctverec: Ctverec = {
    druh: "ctverec",
    strana: 4
};

console.log(`Plocha kruhu: ${vypoctiPlochu(kruh)}`);
console.log(`Plocha čtverce: ${vypoctiPlochu(ctverec)}`);</code></pre>

    <p>Exhaustive checking je užitečná technika, která využívá vlastnost <code>never</code> typu k zajištění, že jste zpracovali všechny možné případy v diskriminační unii.</p>
</section>